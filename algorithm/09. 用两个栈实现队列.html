<!DOCTYPE html>
<html lang="zh-Hans">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>09. 用两个栈实现队列 | Daqi's blog</title>
<Link rel="stylesheet" href="/css/md.css" />
<Link rel="stylesheet" href="/css/hl.css" />
<style>
#root { padding: 20px; } 
</style>
</head>
<body>
<div id="root">
  <div class="markdown-body">
  <h1 id="09-用两个栈实现队列">09. 用两个栈实现队列</h1>
<h2 id="来源">来源</h2>
<p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a></p>
<h2 id="题目">题目</h2>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>  操作返回 -1 )</p>
<h3 id="示例">示例:</h3>
<h4 id="示例-1">示例 1.</h4>
<pre><code>输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]</code></pre><h4 id="示例-2">示例 2.</h4>
<pre><code>输入：
[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]</code></pre><h3 id="提示：">提示：</h3>
<ul>
<li>1 &lt;= values &lt;= 10000</li>
<li>最多会对 appendTail、deleteHead 进行 10000 次调用</li>
</ul>
<h2 id="思路">思路</h2>
<p>一个栈<code>stackIn</code>用来压入，一个栈<code>stackOut</code>用来弹出，弹出时，如果<code>stackOut</code>没有元素，则把<code>stackOut</code>的元素依次弹出压入<code>stackOut</code>中，此时元素的顺序会逆转（先入变成了先出），然后弹出；如果<code>stackOut</code>有元素，则直接弹出。</p>
<p>复杂度：压入 O(1),弹出 O(n)。</p>
<blockquote>
<p>一定要在<code>stackOut</code>清空之后，再把<code>stackIn</code>的元素灌入<code>stackOut</code>，否则先入的就不能先出了，顺序就乱了。</p>
</blockquote>
<h2 id="解题">解题</h2>
<pre><code class="language-js"><span class="hljs-keyword">var</span> CQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.stackIn = [];
  <span class="hljs-keyword">this</span>.stackOut = [];
  <span class="hljs-comment">// 只用 push 和 pop</span>
};

<span class="hljs-comment">/**
 * @param {number} value
 * @return {void}
 */</span>
CQueue.prototype.appendTail = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">this</span>.stackIn.push(value);
};

<span class="hljs-comment">/**
 * @return {number}
 */</span>
CQueue.prototype.deleteHead = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackOut.length === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.stackIn.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stackOut.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.stackIn.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.stackOut.push(<span class="hljs-keyword">this</span>.stackIn.pop());
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stackOut.pop();
};

<span class="hljs-comment">/**
 * Your CQueue object will be instantiated and called as such:
 * var obj = new CQueue()
 * obj.appendTail(value)
 * var param_2 = obj.deleteHead()
 */</span></code></pre>
<h2 id="题目-2">题目 2</h2>
<h3 id="用两个队列实现栈">用两个队列实现栈</h3>
<p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p>
<h2 id="思路-1">思路</h2>
<p>把元素从一个队列灌入另一个队列，直到剩最后一个元素，弹出此元素，然后两个队列指针互换。</p>
<p>复杂度：压入 O(1),弹出 O(n)。</p>
<h2 id="解题-1">解题</h2>
<pre><code class="language-js"><span class="hljs-comment">/**
 * Initialize your data structure here.
 */</span>
<span class="hljs-keyword">var</span> MyStack = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.queueIn = [];
  <span class="hljs-keyword">this</span>.queueOut = [];
  <span class="hljs-comment">// 只能用push、shift</span>
};

<span class="hljs-comment">/**
 * Push element x onto stack.
 * @param {number} x
 * @return {void}
 */</span>
MyStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">this</span>.queueIn.push(x);
};

<span class="hljs-comment">/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */</span>
MyStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.queueIn.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.queueIn.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">this</span>.queueOut.push(<span class="hljs-keyword">this</span>.queueIn.shift());
  }
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">this</span>.queueIn.shift();
  <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">this</span>.queueIn;
  <span class="hljs-keyword">this</span>.queueIn = <span class="hljs-keyword">this</span>.queueOut;
  <span class="hljs-keyword">this</span>.queueOut = temp;
  <span class="hljs-keyword">return</span> res;
};

<span class="hljs-comment">/**
 * Get the top element.
 * @return {number}
 */</span>
MyStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.queueIn.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.queueIn.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">this</span>.queueOut.push(<span class="hljs-keyword">this</span>.queueIn.shift());
  }
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">this</span>.queueIn.shift();
  <span class="hljs-keyword">this</span>.queueOut.push(res);
  <span class="hljs-keyword">const</span> temp = <span class="hljs-keyword">this</span>.queueIn;
  <span class="hljs-keyword">this</span>.queueIn = <span class="hljs-keyword">this</span>.queueOut;
  <span class="hljs-keyword">this</span>.queueOut = temp;
  <span class="hljs-keyword">return</span> res;
};

<span class="hljs-comment">/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */</span>
MyStack.prototype.empty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queueIn.length === <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */</span></code></pre>
<blockquote>
<p><strong>从零开始学算法</strong><br><a href="https://github.com/daqi/re0-algorithm/issues">https://github.com/daqi/re0-algorithm/issues</a><br>欢迎 start &amp; watch</p>
</blockquote>

  </div>
</div>
</body>
</html>